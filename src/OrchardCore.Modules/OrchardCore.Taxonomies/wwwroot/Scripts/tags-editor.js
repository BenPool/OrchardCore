/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

function initializeTagsEditor(element) {
  if (element) {
    var elementId = element.id;
    var vueMultiselect = Vue.component('vue-multiselect', window.VueMultiselect["default"]);
    var vm = new Vue({
      el: '#' + elementId,
      components: {
        'vue-multiselect': vueMultiselect
      },
      data: function data() {
        var allTerms = JSON.parse(element.dataset.allTerms || "[]");
        selectedTerms = allTerms.filter(function (term) {
          return term.selected;
        }); //var tenantPath = element.dataset.tenantPath;
        //var searchApiUrl = element.dataset.searchUrl;
        //TODO settings.Leaves can be used to filter terms.
        // or a seperate settings for tags.

        return {
          termEntriesKey: element.dataset.termEntriesKey,
          contentItemIdKey: element.dataset.contentItemIdKey,
          selectedKey: element.dataset.selectedKey,
          partName: element.dataset.partName,
          fieldName: element.dataset.fieldName,
          settings: element.dataset.settings,
          arrayOfItems: selectedTerms,
          options: allTerms
        };
      },
      computed: {
        //TODO
        isDisabled: function isDisabled() {
          return this.arrayOfItems.length > 0 && !multiple;
        }
      },
      created: function created() {
        var self = this;
      },
      methods: {
        addTag: function addTag(newTag) {// TODO create tag term 
          // either create new option (term / tag) here, with id generated by js, but would only be able to set displayText of the new term.
          // and when supply it back to driver, track this, and create term in driver. or we fire of to a controller here, to create.
          // either way there is still only have displayText as a property to set on taxonomy-term. Unless via a modal... modal is not ideal though.
        },
        onSelect: function onSelect(selectedOption) {
          var option = this.options.find(function (element) {
            return element.contentItemId === selectedOption.contentItemId;
          });
          option.selected = true;
          $(document).trigger('contentpreview:render');
        },
        onRemove: function onRemove(removedOption) {
          var option = this.options.find(function (element) {
            return element.contentItemId === removedOption.contentItemId;
          });
          option.selected = false;
          $(document).trigger('contentpreview:render');
        },
        termEntriesContentItemName: function termEntriesContentItemName(option) {
          var indexOf = this.options.indexOf(option);
          return "".concat(this.partName, ".").concat(this.fieldName, ".").concat(this.termEntriesKey, "[").concat(indexOf, "].").concat(this.contentItemIdKey);
        },
        termEntriesSelectedName: function termEntriesSelectedName(option) {
          var indexOf = this.options.indexOf(option);
          return "".concat(this.partName, ".").concat(this.fieldName, ".").concat(this.termEntriesKey, "[").concat(indexOf, "].").concat(this.selectedKey);
        }
      }
    });
    return vm;
  }
}